CodeMirror.defineMode("clike", function (config, parserConfig) {
    var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;

    var curPunc;

    function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
            var result = hooks[ch](stream, state);
            if (result !== false) return result;
        }
        if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
        }
        if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
            curPunc = ch;
            return null;
        }
        if (/\d/.test(ch)) {
            stream.eatWhile(/[\w\.]/);
            return "number";
        }
        if (ch == "/") {
            if (stream.eat("*")) {
                state.tokenize = tokenComment;
                return tokenComment(stream, state);
            }
            if (stream.eat("/")) {
                stream.skipToEnd();
                return "comment";
            }
        }
        if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return "operator";
        }
        stream.eatWhile(/[\w\$_]/);
        var cur = stream.current();
        if (keywords.propertyIsEnumerable(cur)) {
            if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
            return "keyword";
        }
        if (builtin.propertyIsEnumerable(cur)) {
            if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
            return "builtin";
        }
        if (atoms.propertyIsEnumerable(cur)) return "atom";
        return "variable";
    }

    function tokenString(quote) {
        return function (stream, state) {
            var escaped = false, next, end = false;
            while ((next = stream.next()) != null) {
                if (next == quote && !escaped) { end = true; break; }
                escaped = !escaped && next == "\\";
            }
            if (end || !(escaped || multiLineStrings))
                state.tokenize = null;
            return "string";
        };
    }

    function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
                state.tokenize = null;
                break;
            }
            maybeEnd = (ch == "*");
        }
        return "comment";
    }

    function Context(indented, column, type, align, prev) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.align = align;
        this.prev = prev;
    }
    function pushContext(state, col, type) {
        var indent = state.indented;
        if (state.context && state.context.type == "statement")
            indent = state.context.indented;
        return state.context = new Context(indent, col, type, null, state.context);
    }
    function popContext(state) {
        var t = state.context.type;
        if (t == ")" || t == "]" || t == "}")
            state.indented = state.context.indented;
        return state.context = state.context.prev;
    }

    // Interface

    return {
        startState: function (basecolumn) {
            return {
                tokenize: null,
                context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
                indented: 0,
                startOfLine: true
            };
        },

        token: function (stream, state) {
            var ctx = state.context;
            if (stream.sol()) {
                if (ctx.align == null) ctx.align = false;
                state.indented = stream.indentation();
                state.startOfLine = true;
            }
            if (stream.eatSpace()) return null;
            curPunc = null;
            var style = (state.tokenize || tokenBase)(stream, state);
            if (style == "comment" || style == "meta") return style;
            if (ctx.align == null) ctx.align = true;

            if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);
            else if (curPunc == "{") pushContext(state, stream.column(), "}");
            else if (curPunc == "[") pushContext(state, stream.column(), "]");
            else if (curPunc == "(") pushContext(state, stream.column(), ")");
            else if (curPunc == "}") {
                while (ctx.type == "statement") ctx = popContext(state);
                if (ctx.type == "}") ctx = popContext(state);
                while (ctx.type == "statement") ctx = popContext(state);
            }
            else if (curPunc == ctx.type) popContext(state);
            else if (((ctx.type == "}" || ctx.type == "top") && curPunc != ';') || (ctx.type == "statement" && curPunc == "newstatement"))
                pushContext(state, stream.column(), "statement");
            state.startOfLine = false;
            return style;
        },

        indent: function (state, textAfter) {
            if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
            var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
            if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
            var closing = firstChar == ctx.type;
            if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
            else if (ctx.align && (!dontAlignCalls || ctx.type != ")")) return ctx.column + (closing ? 0 : 1);
            else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;
            else return ctx.indented + (closing ? 0 : indentUnit);
        },

        electricChars: "{}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        lineComment: "//",
        fold: "brace"
    };
});

(function () {
    function words(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
        return obj;
    }
    var cKeywords = "auto if break int case long char register continue return default short do sizeof " +
    "double static else struct entry switch extern typedef float union for unsigned " +
    "goto while enum void const signed volatile";

    function cppHook(stream, state) {
        if (!state.startOfLine) return false;
        for (; ; ) {
            if (stream.skipTo("\\")) {
                stream.next();
                if (stream.eol()) {
                    state.tokenize = cppHook;
                    break;
                }
            } else {
                stream.skipToEnd();
                state.tokenize = null;
                break;
            }
        }
        return "meta";
    }

    // C#-style strings where "" escapes a quote.
    function tokenAtString(stream, state) {
        var next;
        while ((next = stream.next()) != null) {
            if (next == '"' && !stream.eat('"')) {
                state.tokenize = null;
                break;
            }
        }
        return "string";
    }

    function def(mimes, mode) {
        var words = [];
        function add(obj) {
            if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
                words.push(prop);
        }
        add(mode.keywords);
        add(mode.builtin);
        add(mode.atoms);
        if (words.length) {
            mode.helperType = mimes[0];
            CodeMirror.registerHelper("hintWords", mimes[0], words);
        }

        for (var i = 0; i < mimes.length; ++i)
            CodeMirror.defineMIME(mimes[i], mode);
    }

    def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
        name: "clike",
        keywords: words(cKeywords),
        blockKeywords: words("case do else for if switch while struct"),
        atoms: words("null"),
        hooks: { "#": cppHook },
        modeProps: { fold: ["brace", "include"] }
    });

    def(["text/x-c++src", "text/x-c++hdr"], {
        name: "clike",
        keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try bool explicit new " +
                    "static_cast typeid catch operator template typename class friend private " +
                    "this using const_cast inline public throw virtual delete mutable protected " +
                    "wchar_t"),
        blockKeywords: words("catch class do else finally for if struct switch try while"),
        atoms: words("true false null"),
        hooks: { "#": cppHook },
        modeProps: { fold: ["brace", "include"] }
    });
    CodeMirror.defineMIME("text/x-java", {
        name: "clike",
        keywords: words("abstract assert boolean break byte case catch char class const continue default " +
                    "do double else enum extends final finally float for goto if implements import " +
                    "instanceof int interface long native new package private protected public " +
                    "return short static strictfp super switch synchronized this throw throws transient " +
                    "try void volatile while"),
        blockKeywords: words("catch class do else finally for if switch try while"),
        atoms: words("true false null"),
        hooks: {
            "@": function (stream) {
                stream.eatWhile(/[\w\$_]/);
                return "meta";
            }
        },
        modeProps: { fold: ["brace", "import"] }
    });
    CodeMirror.defineMIME("text/x-csharp", {
        name: "clike",
        keywords: words("abstract as base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in interface internal is lock namespace new" +
                    " operator out override params private protected public readonly ref return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
        blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
        builtin: words("Boolean Byte Char DateTime DateTimeOffset Decimal Double" +
                    " Guid Int16 Int32 Int64 Object SByte Single String TimeSpan UInt16 UInt32" +
                    " UInt64 bool byte char decimal double short int long object" +
                    " sbyte float string ushort uint ulong"),
        atoms: words("true false null"),
        hooks: {
            "@": function (stream, state) {
                if (stream.eat('"')) {
                    state.tokenize = tokenAtString;
                    return tokenAtString(stream, state);
                }
                stream.eatWhile(/[\w\$_]/);
                return "meta";
            }
        }
    });
    CodeMirror.defineMIME("text/x-scala", {
        name: "clike",
        keywords: words(

        /* scala */
      "abstract case catch class def do else extends false final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try trye type val var while with yield _ : = => <- <: " +
      "<% >: # @ " +

        /* package scala */
      "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble " +

      "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector :: #:: " +

        /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"


    ),
        blockKeywords: words("catch class do else finally for forSome if match switch try while"),
        atoms: words("true false null"),
        hooks: {
            "@": function (stream) {
                stream.eatWhile(/[\w\$_]/);
                return "meta";
            }
        }
    });
    def(["x-shader/x-vertex", "x-shader/x-fragment"], {
        name: "clike",
        keywords: words("float int bool void " +
                    "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                    "mat2 mat3 mat4 " +
                    "sampler1D sampler2D sampler3D samplerCube " +
                    "sampler1DShadow sampler2DShadow" +
                    "const attribute uniform varying " +
                    "break continue discard return " +
                    "for while do if else struct " +
                    "in out inout"),
        blockKeywords: words("for while do if else struct"),
        builtin: words("radians degrees sin cos tan asin acos atan " +
                    "pow exp log exp2 sqrt inversesqrt " +
                    "abs sign floor ceil fract mod min max clamp mix step smootstep " +
                    "length distance dot cross normalize ftransform faceforward " +
                    "reflect refract matrixCompMult " +
                    "lessThan lessThanEqual greaterThan greaterThanEqual " +
                    "equal notEqual any all not " +
                    "texture1D texture1DProj texture1DLod texture1DProjLod " +
                    "texture2D texture2DProj texture2DLod texture2DProjLod " +
                    "texture3D texture3DProj texture3DLod texture3DProjLod " +
                    "textureCube textureCubeLod " +
                    "shadow1D shadow2D shadow1DProj shadow2DProj " +
                    "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                    "dFdx dFdy fwidth " +
                    "noise1 noise2 noise3 noise4"),
        atoms: words("true false " +
                "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                "gl_FogCoord " +
                "gl_Position gl_PointSize gl_ClipVertex " +
                "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                "gl_TexCoord gl_FogFragCoord " +
                "gl_FragCoord gl_FrontFacing " +
                "gl_FragColor gl_FragData gl_FragDepth " +
                "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                "gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                "gl_ProjectionMatrixInverseTranspose " +
                "gl_ModelViewProjectionMatrixInverseTranspose " +
                "gl_TextureMatrixInverseTranspose " +
                "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                "gl_FogParameters " +
                "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                "gl_MaxDrawBuffers"),
        hooks: { "#": cppHook },
        modeProps: { fold: ["brace", "include"] }
    });
} ());


///////// for HTML

CodeMirror.defineMode("xml", function (config, parserConfig) {
    function inText(stream, state) {
        function chain(parser) {
            return state.tokenize = parser, parser(stream, state)
        }
        var ch = stream.next(), isClose, c, ok;
        if (ch == "<") {
            if (stream.eat("!"))
                return stream.eat("[") ? stream.match("CDATA[") ? chain(inBlock("atom", "]\]>")) : null : stream.match("--") ? chain(inBlock("comment", "-->")) : stream.match("DOCTYPE", !0, !0) ? (stream.eatWhile(/[\w\._\-]/), chain(doctype(1))) : null;
            if (stream.eat("?"))
                return stream.eatWhile(/[\w\._\-]/), state.tokenize = inBlock("meta", "?>"), "meta";
            for (isClose = stream.eat("/"), tagName = ""; c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/); )
                tagName += c;
            return tagName ? (type = isClose ? "closeTag" : "openTag", state.tokenize = inTag, "tag") : "error"
        }
        return ch == "&" ? (ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";"), ok ? "atom" : "error") : (stream.eatWhile(/[^&<]/), null)
    }
    function inTag(stream, state) {
        var ch = stream.next();
        return ch == ">" || ch == "/" && stream.eat(">") ? (state.tokenize = inText, type = ch == ">" ? "endTag" : "selfcloseTag", "tag") : ch == "=" ? (type = "equals", null) : /[\'\"]/.test(ch) ? (state.tokenize = inAttribute(ch), state.tokenize(stream, state)) : (stream.eatWhile(/[^\s\u00a0=<>\"\']/), "word")
    }
    function inAttribute(quote) {
        return function (stream, state) {
            while (!stream.eol())
                if (stream.next() == quote) {
                    state.tokenize = inTag;
                    break
                }
            return "string"
        }
    }
    function inBlock(style, terminator) {
        return function (stream, state) {
            while (!stream.eol()) {
                if (stream.match(terminator)) {
                    state.tokenize = inText;
                    break
                }
                stream.next()
            }
            return style
        }
    }
    function doctype(depth) {
        return function (stream, state) {
            for (var ch; (ch = stream.next()) != null; ) {
                if (ch == "<")
                    return state.tokenize = doctype(depth + 1), state.tokenize(stream, state);
                if (ch == ">")
                    if (depth == 1) {
                        state.tokenize = inText;
                        break
                    } else
                        return state.tokenize = doctype(depth - 1), state.tokenize(stream, state)
            }
            return "meta"
        }
    }
    function pass() {
        for (var i = arguments.length - 1; i >= 0; i--)
            curState.cc.push(arguments[i])
    }
    function cont() {
        return pass.apply(null, arguments), !0
    }
    function pushContext(tagName, startOfLine) {
        var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || curState.context && curState.context.noIndent;
        curState.context = { prev: curState.context, tagName: tagName, indent: curState.indented, startOfLine: startOfLine, noIndent: noIndent }
    }
    function popContext() {
        curState.context && (curState.context = curState.context.prev)
    }
    function element(type) {
        if (type == "openTag")
            return curState.tagName = tagName, curState.tagStart = curStream.column(), cont(attributes, endtag(curState.startOfLine));
        if (type == "closeTag") {
            var err = !1;
            return curState.context ? curState.context.tagName != tagName && (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase()) && popContext(), err = !curState.context || curState.context.tagName != tagName) : err = !0, err && (setStyle = "error"), cont(endclosetag(err))
        }
        return cont()
    }
    function endtag(startOfLine) {
        return function (type) {
            var tagName = curState.tagName;
            return (curState.tagName = curState.tagStart = null, type == "selfcloseTag" || type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) ? (maybePopContext(tagName.toLowerCase()), cont()) : type == "endTag" ? (maybePopContext(tagName.toLowerCase()), pushContext(tagName, startOfLine), cont()) : cont()
        }
    }
    function endclosetag(err) {
        return function (type) {
            return (err && (setStyle = "error"), type == "endTag") ? (popContext(), cont()) : (setStyle = "error", cont(arguments.callee))
        }
    }
    function maybePopContext(nextTagName) {
        for (var parentTagName; ; ) {
            if (!curState.context)
                return;
            if (parentTagName = curState.context.tagName.toLowerCase(), !Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName))
                return;
            popContext()
        }
    }
    function attributes(type) {
        return type == "word" ? (setStyle = "attribute", cont(attribute, attributes)) : type == "endTag" || type == "selfcloseTag" ? pass() : (setStyle = "error", cont(attributes))
    }
    function attribute(type) {
        return type == "equals" ? cont(attvalue, attributes) : (Kludges.allowMissing ? type == "word" && (setStyle = "attribute") : setStyle = "error", type == "endTag" || type == "selfcloseTag" ? pass() : cont())
    }
    function attvalue(type) {
        return type == "string" ? cont(attvaluemaybe) : type == "word" && Kludges.allowUnquoted ? (setStyle = "string", cont()) : (setStyle = "error", type == "endTag" || type == "selfCloseTag" ? pass() : cont())
    }
    function attvaluemaybe(type) {
        return type == "string" ? cont(attvaluemaybe) : pass()
    }
    var indentUnit = config.indentUnit, multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1, Kludges = parserConfig.htmlMode ? { autoSelfClosers: { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, implicitlyClosed: { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, contextGrabbers: { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0} }, doNotIndent: { pre: !0 }, allowUnquoted: !0, allowMissing: !0} : { autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: !1, allowMissing: !1 }, alignCDATA = parserConfig.alignCDATA, tagName, type, curState, curStream, setStyle;
    return { startState: function () {
        return { tokenize: inText, cc: [], indented: 0, startOfLine: !0, tagName: null, tagStart: null, context: null }
    }, token: function (stream, state) {
        var style, comb;
        if (!state.tagName && stream.sol() && (state.startOfLine = !0, state.indented = stream.indentation()), stream.eatSpace())
            return null;
        if (setStyle = type = tagName = null, style = state.tokenize(stream, state), state.type = type, (style || type) && style != "comment")
            for (curState = state, curStream = stream; ; )
                if (comb = state.cc.pop() || element, comb(type || style))
                    break;
        return state.startOfLine = !1, setStyle || style
    }, indent: function (state, textAfter, fullLine) {
        var context = state.context;
        if (state.tokenize != inTag && state.tokenize != inText || context && context.noIndent)
            return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
        if (state.tagName)
            return state.tagStart + indentUnit * multilineTagIndentFactor;
        if (alignCDATA && /<!\[CDATA\[/.test(textAfter))
            return 0;
        for (context && /^<\//.test(textAfter) && (context = context.prev); context && !context.startOfLine; )
            context = context.prev;
        return context ? context.indent + indentUnit : 0
    }, electricChars: "/", blockCommentStart: "<!--", blockCommentEnd: "-->", configuration: parserConfig.htmlMode ? "html" : "xml"
    }
}), CodeMirror.defineMIME("text/xml", "xml"), CodeMirror.defineMIME("application/xml", "xml"), CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: !0 }), CodeMirror.defineMode("css", function (config) {
    return CodeMirror.getMode(config, "text/css")
}), CodeMirror.defineMode("css-base", function (config, parserConfig) {
    "use strict";
    function ret(style, tp) {
        return type = tp, style
    }
    function tokenBase(stream, state) {
        var ch = stream.next(), result;
        if (hooks[ch] && (result = hooks[ch](stream, state), result !== !1))
            return result;
        if (ch == "@")
            return stream.eatWhile(/[\w\\\-]/), ret("def", stream.current());
        if (ch == "=")
            ret(null, "compare");
        else {
            if ((ch == "~" || ch == "|") && stream.eat("="))
                return ret(null, "compare");
            if (ch == '"' || ch == "'")
                return state.tokenize = tokenString(ch), state.tokenize(stream, state);
            if (ch == "#")
                return stream.eatWhile(/[\w\\\-]/), ret("atom", "hash");
            if (ch == "!")
                return stream.match(/^\s*\w*/), ret("keyword", "important");
            if (/\d/.test(ch))
                return stream.eatWhile(/[\w.%]/), ret("number", "unit");
            if (ch === "-") {
                if (/\d/.test(stream.peek()))
                    return stream.eatWhile(/[\w.%]/), ret("number", "unit");
                if (stream.match(/^[^-]+-/))
                    return ret("meta", "meta")
            } else
                return /[,+>*\/]/.test(ch) ? ret(null, "select-op") : ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : ch == ":" ? ret("operator", ch) : /[;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : ch == "u" && stream.match("rl(") ? (stream.backUp(1), state.tokenize = tokenParenthesized, ret("property", "variable")) : (stream.eatWhile(/[\w\\\-]/), ret("property", "variable"))
        }
    }
    function tokenString(quote, nonInclusive) {
        return function (stream, state) {
            for (var escaped = !1, ch; (ch = stream.next()) != null; ) {
                if (ch == quote && !escaped)
                    break;
                escaped = !escaped && ch == "\\"
            }
            return escaped || (nonInclusive && stream.backUp(1), state.tokenize = tokenBase), ret("string", "string")
        }
    }
    function tokenParenthesized(stream, state) {
        return stream.next(), state.tokenize = stream.match(/\s*[\"\']/, !1) ? tokenBase : tokenString(")", !0), ret(null, "(")
    }
    var indentUnit = config.indentUnit, hooks = parserConfig.hooks || {}, atMediaTypes = parserConfig.atMediaTypes || {}, atMediaFeatures = parserConfig.atMediaFeatures || {}, propertyKeywords = parserConfig.propertyKeywords || {}, colorKeywords = parserConfig.colorKeywords || {}, valueKeywords = parserConfig.valueKeywords || {}, allowNested = !!parserConfig.allowNested, type = null;
    return { startState: function (base) {
        return { tokenize: tokenBase, baseIndent: base || 0, stack: [] }
    }, token: function (stream, state) {
        var style, context, word, newContext, lastState;
        return (state.tokenize = state.tokenize || tokenBase, state.tokenize == tokenBase && stream.eatSpace()) ? null : (style = state.tokenize(stream, state), style && typeof style != "string" && (style = ret(style[0], style[1])), context = state.stack[state.stack.length - 1], style == "variable") ? (type == "variable-definition" && state.stack.push("propertyValue"), "variable-2") : (style == "property" ? (word = stream.current().toLowerCase(), context == "propertyValue" ? style = valueKeywords.hasOwnProperty(word) ? "string-2" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable-2" : context == "rule" ? propertyKeywords.hasOwnProperty(word) || (style += " error") : context == "block" ? style = propertyKeywords.hasOwnProperty(word) ? "property" : colorKeywords.hasOwnProperty(word) ? "keyword" : valueKeywords.hasOwnProperty(word) ? "string-2" : "tag" : context && context != "@media{" ? context == "@media" ? style = atMediaTypes[stream.current()] ? "attribute" : /^(only|not)$/.test(word) ? "keyword" : word == "and" ? "error" : atMediaFeatures.hasOwnProperty(word) ? "error" : "attribute error" : context == "@mediaType" ? style = atMediaTypes.hasOwnProperty(word) ? "attribute" : word == "and" ? "operator" : /^(only|not)$/.test(word) ? "error" : "error" : context == "@mediaType(" ? propertyKeywords.hasOwnProperty(word) || (atMediaTypes.hasOwnProperty(word) ? style = "error" : word == "and" ? style = "operator" : /^(only|not)$/.test(word) ? style = "error" : style += " error") : style = context == "@import" ? "tag" : "error" : style = "tag") : style == "atom" ? context && context != "@media{" && context != "block" ? context == "propertyValue" ? /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current()) || (style += " error") : style = "error" : style = "builtin" : context == "@media" && type == "{" && (style = "error"), type == "{" ? context == "@media" || context == "@mediaType" ? (state.stack.pop(), state.stack[state.stack.length - 1] = "@media{") : (newContext = allowNested ? "block" : "rule", state.stack.push(newContext)) : type == "}" ? (lastState = state.stack[state.stack.length - 1], lastState == "interpolation" && (style = "operator"), state.stack.pop(), context == "propertyValue" && state.stack.pop()) : type == "interpolation" ? state.stack.push("interpolation") : type == "@media" ? state.stack.push("@media") : type == "@import" ? state.stack.push("@import") : context == "@media" && /\b(keyword|attribute)\b/.test(style) ? state.stack.push("@mediaType") : context == "@mediaType" && stream.current() == "," ? state.stack.pop() : context == "@mediaType" && type == "(" ? state.stack.push("@mediaType(") : context == "@mediaType(" && type == ")" ? state.stack.pop() : (context == "rule" || context == "block") && type == ":" ? state.stack.push("propertyValue") : context == "propertyValue" && type == ";" ? state.stack.pop() : context == "@import" && type == ";" && state.stack.pop(), style)
    }, indent: function (state, textAfter) {
        var n = state.stack.length;
        return /^\}/.test(textAfter) && (n -= state.stack[state.stack.length - 1] == "propertyValue" ? 2 : 1), state.baseIndent + n * indentUnit
    }, electricChars: "}", blockCommentStart: "/*", blockCommentEnd: "*/"
    }
}), function () {
    function keySet(array) {
        for (var keys = {}, i = 0; i < array.length; ++i)
            keys[array[i]] = !0;
        return keys
    }
    function tokenCComment(stream, state) {
        for (var maybeEnd = !1, ch; (ch = stream.next()) != null; ) {
            if (maybeEnd && ch == "/") {
                state.tokenize = null;
                break
            }
            maybeEnd = ch == "*"
        }
        return ["comment", "comment"]
    }
    var atMediaTypes = keySet(["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"]), atMediaFeatures = keySet(["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"]), propertyKeywords = keySet(["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid-cell", "grid-column", "grid-column-align", "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow", "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span", "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-shadow", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"]), colorKeywords = keySet(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]), valueKeywords = keySet(["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "overlay", "overline", "padding", "padding-box", "painted", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"]);
    CodeMirror.defineMIME("text/css", { atMediaTypes: atMediaTypes, atMediaFeatures: atMediaFeatures, propertyKeywords: propertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, hooks: { "<": function (stream, state) {
        function tokenSGMLComment(stream, state) {
            for (var dashes = 0, ch; (ch = stream.next()) != null; ) {
                if (dashes >= 2 && ch == ">") {
                    state.tokenize = null;
                    break
                }
                dashes = ch == "-" ? dashes + 1 : 0
            }
            return ["comment", "comment"]
        }
        if (stream.eat("!"))
            return state.tokenize = tokenSGMLComment, tokenSGMLComment(stream, state)
    }, "/": function (stream, state) {
        return stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : !1
    } 
    }, name: "css-base"
    }), CodeMirror.defineMIME("text/x-scss", { atMediaTypes: atMediaTypes, atMediaFeatures: atMediaFeatures, propertyKeywords: propertyKeywords, colorKeywords: colorKeywords, valueKeywords: valueKeywords, allowNested: !0, hooks: { $: function (stream) {
        return (stream.match(/^[\w-]+/), stream.peek() == ":") ? ["variable", "variable-definition"] : ["variable", "variable"]
    }, "/": function (stream, state) {
        return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
    }, "#": function (stream) {
        return stream.eat("{") ? ["operator", "interpolation"] : (stream.eatWhile(/[\w\\\-]/), ["atom", "hash"])
    } 
    }, name: "css-base"
    })
} (), CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    function html(stream, state) {
        var tagName = state.htmlState.tagName, style = htmlMode.token(stream, state.htmlState), scriptType, i, tp;
        if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
            for (scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i), scriptType = scriptType ? scriptType[1] : "", scriptType && /[\"\']/.test(scriptType.charAt(0)) && (scriptType = scriptType.slice(1, scriptType.length - 1)), i = 0; i < scriptTypes.length; ++i)
                if (tp = scriptTypes[i], typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
                    tp.mode && (state.token = script, state.localMode = tp.mode, state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, "")));
                    break
                }
        } else
            tagName == "style" && /\btag\b/.test(style) && stream.current() == ">" && (state.token = css, state.localMode = cssMode, state.localState = cssMode.startState(htmlMode.indent(state.htmlState, "")));
        return style
    }
    function maybeBackup(stream, pat, style) {
        var cur = stream.current(), close = cur.search(pat), m;
        return close > -1 ? stream.backUp(cur.length - close) : (m = cur.match(/<\/?$/)) && (stream.backUp(cur.length), stream.match(pat, !1) || stream.match(cur[0])), style
    }
    function script(stream, state) {
        return stream.match(/^<\/\s*script\s*>/i, !1) ? (state.token = html, state.localState = state.localMode = null, html(stream, state)) : maybeBackup(stream, /<\/\s*script\s*>/, state.localMode.token(stream, state.localState))
    }
    function css(stream, state) {
        return stream.match(/^<\/\s*style\s*>/i, !1) ? (state.token = html, state.localState = state.localMode = null, html(stream, state)) : maybeBackup(stream, /<\/\s*style\s*>/, cssMode.token(stream, state.localState))
    }
    var htmlMode = CodeMirror.getMode(config, { name: "xml", htmlMode: !0 }), cssMode = CodeMirror.getMode(config, "css"), scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes, i, conf;
    if (scriptTypes.push({ matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i, mode: CodeMirror.getMode(config, "javascript") }), scriptTypesConf)
        for (i = 0; i < scriptTypesConf.length; ++i)
            conf = scriptTypesConf[i], scriptTypes.push({ matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode) });
    return scriptTypes.push({ matches: /./, mode: CodeMirror.getMode(config, "text/plain") }), { startState: function () {
        var state = htmlMode.startState();
        return { token: html, localMode: null, localState: null, htmlState: state }
    }, copyState: function (state) {
        if (state.localState)
            var local = CodeMirror.copyState(state.localMode, state.localState);
        return { token: state.token, localMode: state.localMode, localState: local, htmlState: CodeMirror.copyState(htmlMode, state.htmlState) }
    }, token: function (stream, state) {
        return state.token(stream, state)
    }, indent: function (state, textAfter) {
        return !state.localMode || /^\s*<\//.test(textAfter) ? htmlMode.indent(state.htmlState, textAfter) : state.localMode.indent ? state.localMode.indent(state.localState, textAfter) : CodeMirror.Pass
    }, electricChars: "/{}:", innerMode: function (state) {
        return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode }
    } 
    }
}, "xml", "javascript", "css"), CodeMirror.defineMIME("text/html", "htmlmixed"), CodeMirror.defineMode("javascript", function (config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonMode = parserConfig.json;
    var isTS = parserConfig.typescript;

    // Tokenizer

    var keywords = function () {
        function kw(type) { return { type: type, style: "keyword" }; }
        var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
        var operator = kw("operator"), atom = { type: "atom", style: "atom" };

        var jsKeywords = {
            "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
            "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
            "var": kw("var"), "const": kw("var"), "let": kw("var"),
            "function": kw("function"), "catch": kw("catch"),
            "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
            "in": operator, "typeof": operator, "instanceof": operator,
            "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
            "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
            "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
        };

        // Extend the 'normal' keywords with the TypeScript language extensions
        if (isTS) {
            var type = { type: "variable", style: "variable-3" };
            var tsKeywords = {
                // object-like things
                "interface": kw("interface"),
                "extends": kw("extends"),
                "constructor": kw("constructor"),

                // scope modifiers
                "public": kw("public"),
                "private": kw("private"),
                "protected": kw("protected"),
                "static": kw("static"),

                // types
                "string": type, "number": type, "bool": type, "any": type
            };

            for (var attr in tsKeywords) {
                jsKeywords[attr] = tsKeywords[attr];
            }
        }

        return jsKeywords;
    } ();

    var isOperatorChar = /[+\-*&%=<>!?|~^]/;

    function nextUntilUnescaped(stream, end) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
            if (next == end && !escaped)
                return false;
            escaped = !escaped && next == "\\";
        }
        return escaped;
    }

    // Used as scratch variables to communicate multiple values without
    // consing up tons of objects.
    var type, content;
    function ret(tp, style, cont) {
        type = tp; content = cont;
        return style;
    }
    function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
            return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
            return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
            return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
            return ret("=>");
        } else if (ch == "0" && stream.eat(/x/i)) {
            stream.eatWhile(/[\da-f]/i);
            return ret("number", "number");
        } else if (/\d/.test(ch)) {
            stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
            return ret("number", "number");
        } else if (ch == "/") {
            if (stream.eat("*")) {
                state.tokenize = tokenComment;
                return tokenComment(stream, state);
            } else if (stream.eat("/")) {
                stream.skipToEnd();
                return ret("comment", "comment");
            } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
                nextUntilUnescaped(stream, "/");
                stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
                return ret("regexp", "string-2");
            } else {
                stream.eatWhile(isOperatorChar);
                return ret("operator", null, stream.current());
            }
        } else if (ch == "`") {
            state.tokenize = tokenQuasi;
            return tokenQuasi(stream, state);
        } else if (ch == "#") {
            stream.skipToEnd();
            return ret("error", "error");
        } else if (isOperatorChar.test(ch)) {
            stream.eatWhile(isOperatorChar);
            return ret("operator", null, stream.current());
        } else {
            stream.eatWhile(/[\w\$_]/);
            var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
            return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
        }
    }

    function tokenString(quote) {
        return function (stream, state) {
            if (!nextUntilUnescaped(stream, quote))
                state.tokenize = tokenBase;
            return ret("string", "string");
        };
    }

    function tokenComment(stream, state) {
        var maybeEnd = false, ch;
        while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
                state.tokenize = tokenBase;
                break;
            }
            maybeEnd = (ch == "*");
        }
        return ret("comment", "comment");
    }

    function tokenQuasi(stream, state) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
            if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
                state.tokenize = tokenBase;
                break;
            }
            escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
    }

    var brackets = "([{}])";
    // This is a crude lookahead trick to try and notice that we're
    // parsing the argument patterns for a fat-arrow function before we
    // actually hit the arrow token. It only works if the arrow is on
    // the same line as the arguments and there's no strange noise
    // (comments) in between. Fallback is to only notice when we hit the
    // arrow, and not declare the arguments as locals for the arrow
    // body.
    function findFatArrow(stream, state) {
        if (state.fatArrowAt) state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0) return;

        var depth = 0, sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
            var ch = stream.string.charAt(pos);
            var bracket = brackets.indexOf(ch);
            if (bracket >= 0 && bracket < 3) {
                if (!depth) { ++pos; break; }
                if (--depth == 0) break;
            } else if (bracket >= 3 && bracket < 6) {
                ++depth;
            } else if (/[$\w]/.test(ch)) {
                sawSomething = true;
            } else if (sawSomething && !depth) {
                ++pos;
                break;
            }
        }
        if (sawSomething && !depth) state.fatArrowAt = pos;
    }

    // Parser

    var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true };

    function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
    }

    function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next)
            if (v.name == varname) return true;
        for (var cx = state.context; cx; cx = cx.prev) {
            for (var v = cx.vars; v; v = v.next)
                if (v.name == varname) return true;
        }
    }

    function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        // Communicate our context to the combinators.
        // (Less wasteful than consing up a hundred closures on every call.)
        cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

        if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = true;

        while (true) {
            var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
            if (combinator(type, content)) {
                while (cc.length && cc[cc.length - 1].lex)
                    cc.pop()();
                if (cx.marked) return cx.marked;
                if (type == "variable" && inScope(state, content)) return "variable-2";
                return style;
            }
        }
    }

    // Combinator utils

    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
    }
    function cont() {
        pass.apply(null, arguments);
        return true;
    }
    function register(varname) {
        function inList(list) {
            for (var v = list; v; v = v.next)
                if (v.name == varname) return true;
            return false;
        }
        var state = cx.state;
        if (state.context) {
            cx.marked = "def";
            if (inList(state.localVars)) return;
            state.localVars = { name: varname, next: state.localVars };
        } else {
            if (inList(state.globalVars)) return;
            if (parserConfig.globalVars)
                state.globalVars = { name: varname, next: state.globalVars };
        }
    }

    // Combinators

    var defaultVars = { name: "this", next: { name: "arguments"} };
    function pushcontext() {
        cx.state.context = { prev: cx.state.context, vars: cx.state.localVars };
        cx.state.localVars = defaultVars;
    }
    function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
    }
    function pushlex(type, info) {
        var result = function () {
            var state = cx.state, indent = state.indented;
            if (state.lexical.type == "stat") indent = state.lexical.indented;
            state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
    }
    function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
            if (state.lexical.type == ")")
                state.indented = state.lexical.indented;
            state.lexical = state.lexical.prev;
        }
    }
    poplex.lex = true;

    function expect(wanted) {
        return function (type) {
            if (type == wanted) return cont();
            else if (wanted == ";") return pass();
            else return cont(arguments.callee);
        };
    }

    function statement(type, value) {
        if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "{") return cont(pushlex("}"), block, poplex);
        if (type == ";") return cont();
        if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), forspec, poplex, statement, poplex);
        if (type == "variable") return cont(pushlex("stat"), maybelabel);
        if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
        if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
        if (type == "class") return cont(pushlex("form"), className, objlit, poplex);
        if (type == "export") return cont(pushlex("form"), afterExport, poplex);
        if (type == "import") return cont(pushlex("form"), afterImport, poplex);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function expression(type) {
        return expressionInner(type, false);
    }
    function expressionNoComma(type) {
        return expressionInner(type, true);
    }
    function expressionInner(type, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
            var body = noComma ? arrowBodyNoComma : arrowBody;
            if (type == "(") return cont(pushcontext, commasep(pattern, ")"), expect("=>"), body, popcontext);
            else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }

        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
        if (type == "function") return cont(functiondef);
        if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
        if (type == "[") return cont(pushlex("]"), expressionNoComma, maybeArrayComprehension, poplex, maybeop);
        if (type == "{") return cont(commasep(objprop, "}"), maybeop);
        return cont();
    }
    function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
    }
    function maybeexpressionNoComma(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expressionNoComma);
    }

    function maybeoperatorComma(type, value) {
        if (type == ",") return cont(expression);
        return maybeoperatorNoComma(type, value, false);
    }
    function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
            if (/\+\+|--/.test(value)) return cont(me);
            if (value == "?") return cont(expression, expect(":"), expr);
            return cont(expr);
        }
        if (type == "quasi") { cx.cc.push(me); return quasi(value); }
        if (type == ";") return;
        if (type == "(") return cont(commasep(expressionNoComma, ")", "call"), me);
        if (type == ".") return cont(property, me);
        if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    }
    function quasi(value) {
        if (!value) debugger;
        if (value.slice(value.length - 2) != "${") return cont();
        return cont(expression, continueQuasi);
    }
    function continueQuasi(type) {
        if (type == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont();
        }
    }
    function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        if (type == "{") return pass(statement);
        return pass(expression);
    }
    function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        if (type == "{") return pass(statement);
        return pass(expressionNoComma);
    }
    function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type) {
        if (type == "variable") { cx.marked = "property"; return cont(); }
    }
    function objprop(type, value) {
        if (type == "variable") {
            cx.marked = "property";
            if (value == "get" || value == "set") return cont(getterSetter);
        } else if (type == "number" || type == "string") {
            cx.marked = type + " property";
        } else if (type == "[") {
            return cont(expression, expect("]"), afterprop);
        }
        if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);
    }
    function getterSetter(type) {
        if (type != "variable") return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
    }
    function afterprop(type) {
        if (type == ":") return cont(expressionNoComma);
        if (type == "(") return pass(functiondef);
    }
    function commasep(what, end, info) {
        function proceed(type) {
            if (type == ",") {
                var lex = cx.state.lexical;
                if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
                return cont(what, proceed);
            }
            if (type == end) return cont();
            return cont(expect(end));
        }
        return function (type) {
            if (type == end) return cont();
            if (info === false) return pass(what, proceed);
            return pass(pushlex(end, info), what, proceed, poplex);
        };
    }
    function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
    }
    function maybetype(type) {
        if (isTS && type == ":") return cont(typedef);
    }
    function typedef(type) {
        if (type == "variable") { cx.marked = "variable-3"; return cont(); }
    }
    function vardef() {
        return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type, value) {
        if (type == "variable") { register(value); return cont(); }
        if (type == "[") return cont(commasep(pattern, "]"));
        if (type == "{") return cont(commasep(proppattern, "}"));
    }
    function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
            register(value);
            return cont(maybeAssign);
        }
        if (type == "variable") cx.marked = "property";
        return cont(expect(":"), pattern, maybeAssign);
    }
    function maybeAssign(_type, value) {
        if (value == "=") return cont(expressionNoComma);
    }
    function vardefCont(type) {
        if (type == ",") return cont(vardef);
    }
    function maybeelse(type, value) {
        if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);
    }
    function forspec(type) {
        if (type == "(") return cont(pushlex(")"), forspec1, expect(")"));
    }
    function forspec1(type) {
        if (type == "var") return cont(vardef, expect(";"), forspec2);
        if (type == ";") return cont(forspec2);
        if (type == "variable") return cont(formaybeinof);
        return pass(expression, expect(";"), forspec2);
    }
    function formaybeinof(_type, value) {
        if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
        return cont(maybeoperatorComma, forspec2);
    }
    function forspec2(type, value) {
        if (type == ";") return cont(forspec3);
        if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
        return pass(expression, expect(";"), forspec3);
    }
    function forspec3(type) {
        if (type != ")") cont(expression);
    }
    function functiondef(type, value) {
        if (value == "*") { cx.marked = "keyword"; return cont(functiondef); }
        if (type == "variable") { register(value); return cont(functiondef); }
        if (type == "(") return cont(pushcontext, commasep(funarg, ")"), statement, popcontext);
    }
    function funarg(type) {
        if (type == "spread") return cont(funarg);
        return pass(pattern, maybetype);
    }
    function className(type, value) {
        if (type == "variable") { register(value); return cont(classNameAfter); }
    }
    function classNameAfter(_type, value) {
        if (value == "extends") return cont(expression);
    }
    function objlit(type) {
        if (type == "{") return cont(commasep(objprop, "}"));
    }
    function afterModule(type, value) {
        if (type == "string") return cont(statement);
        if (type == "variable") { register(value); return cont(maybeFrom); }
    }
    function afterExport(_type, value) {
        if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
        if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
        return pass(statement);
    }
    function afterImport(type) {
        if (type == "string") return cont();
        return pass(importSpec, maybeFrom);
    }
    function importSpec(type, value) {
        if (type == "{") return cont(commasep(importSpec, "}"));
        if (type == "variable") register(value);
        return cont();
    }
    function maybeFrom(_type, value) {
        if (value == "from") { cx.marked = "keyword"; return cont(expression); }
    }
    function maybeArrayComprehension(type) {
        if (type == "for") return pass(comprehension);
        if (type == ",") return cont(commasep(expressionNoComma, "]", false));
        return pass(commasep(expressionNoComma, "]", false));
    }
    function comprehension(type) {
        if (type == "for") return cont(forspec, comprehension);
        if (type == "if") return cont(expression, comprehension);
    }

    // Interface

    return {
        startState: function (basecolumn) {
            var state = {
                tokenize: tokenBase,
                lastType: "sof",
                cc: [],
                lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
                localVars: parserConfig.localVars,
                context: parserConfig.localVars && { vars: parserConfig.localVars },
                indented: 0
            };
            if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;
            return state;
        },

        token: function (stream, state) {
            if (stream.sol()) {
                if (!state.lexical.hasOwnProperty("align"))
                    state.lexical.align = false;
                state.indented = stream.indentation();
                findFatArrow(stream, state);
            }
            if (state.tokenize != tokenComment && stream.eatSpace()) return null;
            var style = state.tokenize(stream, state);
            if (type == "comment") return style;
            state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
            return parseJS(state, style, type, content, stream);
        },

        indent: function (state, textAfter) {
            if (state.tokenize == tokenComment) return CodeMirror.Pass;
            if (state.tokenize != tokenBase) return 0;
            var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
            // Kludge to prevent 'maybelse' from blocking lexical scope pops
            for (var i = state.cc.length - 1; i >= 0; --i) {
                var c = state.cc[i];
                if (c == poplex) lexical = lexical.prev;
                else if (c != maybeelse) break;
            }
            if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
            if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
                lexical = lexical.prev;
            var type = lexical.type, closing = firstChar == type;

            if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
            else if (type == "form" && firstChar == "{") return lexical.indented;
            else if (type == "form") return lexical.indented + indentUnit;
            else if (type == "stat")
                return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
            else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
                return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
            else if (lexical.align) return lexical.column + (closing ? 0 : 1);
            else return lexical.indented + (closing ? 0 : indentUnit);
        },

        electricChars: ":{}",
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        lineComment: jsonMode ? null : "//",
        fold: "brace",

        helperType: jsonMode ? "json" : "javascript",
        jsonMode: jsonMode
    };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

